Тема: Реалізація "Гри Життя" мовою C++.
1. Правила симуляції: Всесвіт гри — це сітка. У кожної клітини є 8 сусідів. На кожному кроці (поколінні) доля клітини вирішується так:
--Виживання: Жива клітина з 2 або 3 живими сусідами залишається живою.
--Смерть: Жива клітина помирає, якщо сусідів менше 2 або більше 3.
--Народження: Мертва клітина стає живою, якщо має рівно 3 живих сусідів.
2. Технічні рішення:
--std::vector<uint8_t> замість bool: Стандартний std::vector<bool> у C++ є спеціалізованим і зберігає дані бітами (для економії пам'яті). Однак процесору для роботи з бітами потрібні додаткові операції (маски, зсуви). Використання uint8_t (найменшого цілого числа) дозволяє процесору звертатися до комірок пам'яті напряму, що збільшує швидкодію в інтенсивних циклах.
--Подвійна буферизація: У програмі використовується два масиви: grid (поточний стан) та nextGrid (майбутній стан).
----Проблема: Якщо змінювати клітини "на льоту" в одному масиві, зміна клітини (0,0) вплине на розрахунок її сусіда (0,1) у тому ж самому ході, що порушує правила.
----Рішення: Код читає з grid, а пише в nextGrid. Після завершення циклу він просто замінює старий кадр новим.
--Тороїдальна топологія: У функції countNeighbors використовується оператор модуля %. Це дозволяє з'єднати лівий край з правим, а верхній з нижнім. Це усуває проблему "мертвих кордонів" і дозволяє фігурам рухатися нескінченно.
--Буферизація виводу: Вивід у консоль  — це дуже повільна операція. Якщо виводити по одному символу в циклі, екран буде сильно мерехтіти. Варто зібрати все зображення в один довгий рядок std::string і виводити його однією командою.
--ANSI Escape Codes: Замість системної команди system("cls"), яка щоразу запускає зовнішній процес очищення екрану (що дуже повільно), варто відправляти терміналу спецкод \033[H\033[2J. Це каже терміналу: "Перемісти курсор додому і очисти екран".